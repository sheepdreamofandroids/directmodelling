#summary What is Direct Modelling?

= Direct Modelling =

The axiom of DM is that the structure of the code of your model should reflect the structure of your thoughts about the functionality of your application. This may seem obvious or even implied by the word “model”, yet in practice it is often forgotten or simply ignored.

http://lh4.googleusercontent.com/V9vXWqJvAqf4nW9KKM4peRuPjdZC9uvG0YlDdgNBUIWWReMIsZbSq7fDJcDWyCdFBpblEhIWitxA6o6tz-OSb4MB8HKRUvca9EF-tGOeD6sT0Y2Btg?.png

Typical models in the java world consist of classes containing private fields with corresponding dumb getters and setters. Usually they are stripped of any and all logic, which is “conveniently” placed in controllers or similar containers of “glue” code. This is not in the spirit of a “model” though. It is not in the spirit of Object Orientation either.

Object Orientation differentiates itself from other methodologies by emphasizing Objects with encapsulated state AND behaviour. A JavaBean that simply stores some fields does not have any interesting behaviour to reuse.

== Advantages of DM = 

Assuming that your idea of how the app should work is nearly perfect, this should not change a lot anymore. If it is not, you have no business coding yet! This implies that changes to the model should be small and rare. Therefore it is very useful and practical to write tests for this model.

One or several presentations layered on top of the model might change more often. Given tested, reusable components, they should work correctly as long as the model is correct since the binding is trivial and there is very little glue code needed.

DM will enforce a strict separation of your model and your presentation while providing a rich, technology neutral interface for binding the two together.

In the end, DM should make your code easier to maintain with less bugs.

== What DM is NOT ==

 * DM is not a new technology that allows you to do anything you couldn’t do before.
 * DM does not allow you to create new software faster.
